how can i call this ?

from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import yaml
import numpy as np

# Named constants for special components
OUTFLOW_COMPONENT = 10
FE_COMPONENT = 20
POWER_LAW_RANGE_THRESHOLD = 2000

@dataclass
class RegionEntry:
    center: float
    line_name: str
    kind: str
    component: int
    amplitude: Optional[float] = None
    profile: Optional[str] = None
    how: Optional[str] = None

class TiedParameterBuilder:
    """
    Encapsulates logic for generating tied-parameter pairs.
    """
    @staticmethod
    def basic_ties(known_pairs: List[Tuple[List[str], List[str]]]) -> List[List[str]]:
        ties: List[List[str]] = []
        for names, params in known_pairs:
            ties.append(params.copy())
        return ties

    @staticmethod
    def fe_ties(entries: List[RegionEntry]) -> List[List[str]]:
        centers = np.array([e.center for e in entries])
        kinds = [e.kind for e in entries]
        idx_center = int(np.argmin(abs(centers - np.median(centers))))
        ties: List[List[str]] = []
        for i, e in enumerate(entries):
            if i == idx_center or 'fe' not in e.kind:
                continue
            for p in ('center', 'width'):
                ties.append([
                    f"{p}_{e.line_name}_{e.component}_{e.kind}",
                    f"{p}_{entries[idx_center].line_name}_{entries[idx_center].component}_{entries[idx_center].kind}"
                ])
        return ties

class RegionBuilder:
    """
    Builds spectral fitting regions from YAML templates, with narrow, broad,
    outflow, and FeII components, plus parameter tying.
    """
    known_tied_relations: List[Tuple[List[str], List[str]]] = [
        (['OIIIb', 'OIIIc'], ['amplitude_OIIIb_component_narrow', 'amplitude_OIIIc_component_narrow', '*0.3']),
        (['NIIb', 'NIIa'], ['amplitude_NIIb_component_narrow', 'amplitude_NIIa_component_narrow', '*0.3']),
        (['NIIb', 'NIIa'], ['center_NIIb_component_narrow', 'center_NIIa_component_narrow']),
        (['OIIIb', 'OIIIc'], ['center_OIIIb_component_narrow', 'center_OIIIc_component_narrow']),
    ]

    def __init__(
        self,
        xmin: float,
        xmax: float,
        n_narrow: int = 1,
        n_broad: int = 1,
        yaml_paths: Optional[List[Union[str, Path]]] = None
    ) -> None:
        self.xmin: float = xmin
        self.xmax: float = xmax
        self.n_narrow: int = n_narrow
        self.n_broad: int = n_broad
        self.full_regions: Dict[str, Any] = {}
        self.regions_available: List[str] = []
        self.regions_to_fit: List[RegionEntry] = []
        self.tied_params_step_1: List[List[str]] = []
        self.tied_params_step_2: List[List[str]] = []
        self._load_region_templates(yaml_paths)

    def _load_region_templates(self, paths: Optional[List[Union[str, Path]]]) -> None:
        """
        Load YAML files defining spectral regions.
        """
        if not paths:
            raise ValueError("No YAML paths provided for region templates.")

        for p in paths:
            path = Path(p)
            if not path.is_file():
                raise FileNotFoundError(f"Region YAML not found: {path}")
            data = yaml.safe_load(path.read_text())
            key = path.stem
            if 'region' not in data or not isinstance(data['region'], list):
                raise KeyError(f"Missing 'region' list in YAML: {path}")
            self.full_regions[key] = data
        self.regions_available = list(self.full_regions.keys())

    def make_region(
        self,
        xmin: Optional[float] = None,
        xmax: Optional[float] = None,
        n_broad: Optional[int] = None,
        n_narrow: Optional[int] = None,
        main_regions: List[str] = ['hydrogen', 'helium'],
        fe_regions: List[str] = ['Fe_uv'],
        add_outflow: bool = False,
        narrow_plus: bool = False,
        template_mode_fe: bool = False,
        tied_narrow_to: Optional[Union[str, Dict[int, Dict[str, int]]]] = None,
        tied_broad_to: Optional[Union[str, Dict[int, Dict[str, int]]]] = None,
        force_linear: bool = False
    ) -> None:
        # Override defaults
        xmin = xmin if xmin is not None else self.xmin
        xmax = xmax if xmax is not None else self.xmax
        n_broad = n_broad if n_broad is not None else self.n_broad
        n_narrow = n_narrow if n_narrow is not None else self.n_narrow

        self.regions_to_fit.clear()
        self.tied_params_step_1.clear()
        self.tied_params_step_2.clear()

        narrow_keys = ['narrow_basic'] + (['narrow_plus'] if narrow_plus else [])

        for name, region in self.full_regions.items():
            for entry in region['region']:
                center = float(entry.get('center', -np.inf))
                if not (xmin <= center <= xmax):
                    continue
                base = RegionEntry(
                    center=center,
                    line_name=str(entry['line_name']),
                    kind=str(entry.get('kind', '')),  # fallback to empty
                    component=int(entry.get('component', 1)),
                    amplitude=entry.get('amplitude'),
                    profile=entry.get('profile'),
                    how=entry.get('how')
                )
                if name in main_regions:
                    comps = self._handle_main_line(base, n_narrow, n_broad)
                elif name in narrow_keys:
                    comps = self._handle_narrow_line(base, n_narrow, add_outflow)
                elif name == 'broad':
                    comps = self._handle_broad_line(base, n_broad)
                elif name in fe_regions and not template_mode_fe:
                    comps = [self._handle_fe_line(base)]
                else:
                    continue
                self.regions_to_fit.extend(comps)

        if (xmax - xmin) > POWER_LAW_RANGE_THRESHOLD and not force_linear:
            self.regions_to_fit.append(
                RegionEntry(center=0.0, line_name='cont', kind='cont', component=0,
                            profile='power_law')
            )

        # Build tied parameters
        self.tied_params_step_1.extend(
            TiedParameterBuilder.basic_ties(self.known_tied_relations)
        )
        self.tied_params_step_1.extend(
            TiedParameterBuilder.fe_ties(self.regions_to_fit)
        )

        # TODO: Add second-step ties based on tied_narrow_to/broad_to mappings

        # Update instance state
        self.xmin, self.xmax = xmin, xmax
        self.n_narrow, self.n_broad = n_narrow, n_broad

    def _handle_main_line(
        self,
        entry: RegionEntry,
        n_narrow: int,
        n_broad: int
    ) -> List[RegionEntry]:
        comps: List[RegionEntry] = []
        total = n_narrow + n_broad
        for idx in range(total):
            kind = 'narrow' if idx < n_narrow else 'broad'
            comp_num = idx + 1 if kind == 'narrow' else idx - n_narrow + 1
            amp = entry.amplitude if kind == 'narrow' or comp_num == 1 else 0.5
            new = RegionEntry(
                center=entry.center,
                line_name=entry.line_name,
                kind=kind,
                component=comp_num,
                amplitude=amp,
                profile=entry.profile,
                how=entry.how
            )
            comps.append(new)
        return comps

    def _handle_narrow_line(
        self,
        entry: RegionEntry,
        n_narrow: int,
        add_outflow: bool
    ) -> List[RegionEntry]:
        comps: List[RegionEntry] = []
        for idx in range(n_narrow):
            amp = entry.amplitude if idx == 0 else 0.5
            new = RegionEntry(
                center=entry.center,
                line_name=entry.line_name,
                kind='narrow',
                component=idx + 1,
                amplitude=amp,
                profile=entry.profile
            )
            comps.append(new)
            if add_outflow and idx == 0 and 'OIII' in entry.line_name:
                out = RegionEntry(
                    center=entry.center,
                    line_name=entry.line_name,
                    kind='outflow',
                    component=OUTFLOW_COMPONENT,
                    amplitude=entry.amplitude,
                    profile=entry.profile
                )
                comps.append(out)
        return comps

    def _handle_broad_line(
        self,
        entry: RegionEntry,
        n_broad: int
    ) -> List[RegionEntry]:
        comps: List[RegionEntry] = []
        for idx in range(n_broad):
            amp = entry.amplitude if idx == 0 else 0.5
            new = RegionEntry(
                center=entry.center,
                line_name=entry.line_name,
                kind='broad',
                component=idx + 1,
                amplitude=amp,
                profile=entry.profile
            )
            comps.append(new)
        return comps

    def _handle_fe_line(self, entry: RegionEntry) -> RegionEntry:
        return RegionEntry(
            center=entry.center,
            line_name=entry.line_name,
            kind='fe',
            component=FE_COMPONENT,
            amplitude=0.1,
            how='sum'
        )

# Note: Unit tests can be written in a separate test file using pytest,
# testing each public method (e.g., make_region, handler functions).
pytest 

import pytest
import yaml
from pathlib import Path
from region_builder import (
    RegionBuilder,
    RegionEntry,
    TiedParameterBuilder,
    OUTFLOW_COMPONENT,
    FE_COMPONENT,
    POWER_LAW_RANGE_THRESHOLD,
)

# Helper: write minimal YAML templates
@pytest.fixture
def tmp_yaml_dir(tmp_path):
    # Create dummy YAML files for hydrogen, narrow_basic, broad, Fe_uv
    templates = {
        'hydrogen.yaml': {'region': [
            {'center': 5000, 'line_name': 'Hbeta', 'kind': 'hydrogen'},
            {'center': 6600, 'line_name': 'Halpha', 'kind': 'hydrogen'}
        ]},
        'narrow_basic.yaml': {'region': [
            {'center': 4959, 'line_name': 'OIIIb', 'kind': 'narrow'},
            {'center': 5007, 'line_name': 'OIIIc', 'kind': 'narrow'}
        ]},
        'broad.yaml': {'region': [
            {'center': 6563, 'line_name': 'Halpha', 'kind': 'broad'}
        ]},
        'Fe_uv.yaml': {'region': [
            {'center': 3000, 'line_name': 'FeII', 'kind': 'fe'}
        ]},
    }
    paths = []
    for fname, data in templates.items():
        p = tmp_path / fname
        p.write_text(yaml.dump(data))
        paths.append(str(p))
    return paths

# Test loading without paths raises
def test_no_yaml_paths_raises():
    with pytest.raises(ValueError):
        RegionBuilder(4000, 7000)

# Test loading with bad path raises FileNotFoundError
def test_bad_yaml_path(tmp_path):
    bad = tmp_path / 'nosuch.yaml'
    with pytest.raises(FileNotFoundError):
        RegionBuilder(4000, 7000, yaml_paths=[str(bad)])

# Test successful loading of templates
def test_load_templates(tmp_yaml_dir):
    rb = RegionBuilder(4000, 7000, yaml_paths=tmp_yaml_dir)
    assert set(rb.regions_available) == {'hydrogen', 'narrow_basic', 'broad', 'Fe_uv'}

# Test handlers create correct components
@pytest.fixture
def rb(tmp_yaml_dir):
    return RegionBuilder(4000, 7000, n_narrow=2, n_broad=1, yaml_paths=tmp_yaml_dir)

def test_handle_main_line(rb):
    entry = RegionEntry(center=5000, line_name='Hbeta', kind='hydrogen', component=1)
    comps = rb._handle_main_line(entry, n_narrow=2, n_broad=1)
    # Expect 3 components: 2 narrow, 1 broad
    assert len(comps) == 3
    kinds = [c.kind for c in comps]
    assert kinds.count('narrow') == 2
    assert kinds.count('broad') == 1
    # Amplitude defaults: first narrow inherits None, second narrow gets 0.5, broad inherits None
    assert comps[1].amplitude == 0.5

def test_handle_narrow_line(rb):
    entry = RegionEntry(center=5007, line_name='OIIIc', kind='narrow', component=1)
    comps = rb._handle_narrow_line(entry, n_narrow=2, add_outflow=True)
    # Should have 3 entries: 2 narrows + 1 outflow
    assert len(comps) == 3
    outflows = [c for c in comps if c.kind == 'outflow']
    assert outflows and outflows[0].component == OUTFLOW_COMPONENT

def test_handle_broad_line(rb):
    entry = RegionEntry(center=6563, line_name='Halpha', kind='broad', component=1)
    comps = rb._handle_broad_line(entry, n_broad=2)
    assert len(comps) == 2
    assert all(c.kind == 'broad' for c in comps)

def test_handle_fe_line(rb):
    entry = RegionEntry(center=3000, line_name='FeII', kind='fe', component=1)
    fe = rb._handle_fe_line(entry)
    assert isinstance(fe, RegionEntry)
    assert fe.component == FE_COMPONENT

# Test make_region assembles regions and continuum
def test_make_region(rb):
    rb.make_region()
    # Regions to fit should include Hbeta, Halpha, OIII, FeII
    names = {c.line_name for c in rb.regions_to_fit}
    assert 'Hbeta' in names and 'Halpha' in names and 'OIIIb' in names
    # Continuum not added because range =3000< threshold
    assert not any(c.kind == 'cont' for c in rb.regions_to_fit)

# Test continuum included when wide range
def test_continuum_included(tmp_yaml_dir):
    rb2 = RegionBuilder(3000, 6000, yaml_paths=tmp_yaml_dir)
    rb2.make_region(xmin=1000, xmax=4000)
    assert any(c.kind == 'cont' for c in rb2.regions_to_fit)

# Test TiedParameterBuilder.basic_ties
def test_basic_ties():
    pairs = [(['A','B'], ['p1','p2']), (['C'], ['p3','p4'])]
    ties = TiedParameterBuilder.basic_ties(pairs)
    assert ties == [['p1','p2'], ['p3','p4']]

# Test TiedParameterBuilder.fe_ties
def test_fe_ties():
    entries = [
        RegionEntry(center=100, line_name='X', kind='fe', component=20),
        RegionEntry(center=200, line_name='Y', kind='fe', component=20)
    ]
    ties = TiedParameterBuilder.fe_ties(entries)
    # Expect ties for center and width from Y to X
    assert any('center_Y' in t[0] and 'center_X' in t[1] for t in ties)
    assert any('width_Y' in t[0] and 'width_X' in t[1] for t in ties)
####################
"""
Module for fitting spectral emission-line regions with JAX-based minimization.
Provides RegionFitting class with customizable line components and limits.
"""
from __future__ import annotations
import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

import yaml
import jax.numpy as jnp
from jax import jit
import pandas as pd

from sheap.Fitting.functions import linear, gaussian_func, lorentzian_func, power_law
from sheap.Fitting.template_fe_func import fitFeOP, fitFeUV
from sheap.Fitting.utils import combine_auto
from sheap.tools.others import kms_to_wl
from sheap.utils import mask_builder, prepare_spectra
from sheap.Fitting.MasterMinimizer import MasterMinimizer

# Configure module-level logger
logger = logging.getLogger(__name__)

# Constant identifiers for special components
OUTFLOW_COMPONENT = 10  # ID used for outflow line components
FE_COMPONENT = 20       # ID used for Fe emission components
CONT_COMPONENT = 0      # ID used for continuum component

# Default kinematic limits (in km/s) per component kind
DEFAULT_LIMITS = {
    'broad': dict(upper_width=5000.0, lower_width=425.0, center_shift=5000.0),
    'narrow': dict(upper_width=200.0, lower_width=50.0, center_shift=2500.0),
    'outflow': dict(upper_width=5000.0, lower_width=425.0, center_shift=2500.0),
    'fe': dict(upper_width=3000.0, lower_width=210.0, center_shift=2500.0),
}

@dataclass
class FittingLimits:
    """
    Stores width and shift limits for a line component kind.
    Attributes:
        upper_width (float): Maximum velocity width (km/s).
        lower_width (float): Minimum velocity width (km/s).
        center_shift (float): Maximum center shift (km/s).
    """
    upper_width: float
    lower_width: float
    center_shift: float

    @classmethod
    def from_dict(cls, d: Dict[str, float]) -> FittingLimits:
        """Create FittingLimits from a dict with keys matching attributes."""
        return cls(
            upper_width=d['upper_width'],
            lower_width=d['lower_width'],
            center_shift=d['center_shift']
        )

@dataclass
class LineConfig:
    """
    Configuration for a single emission-line component.
    Attributes:
        center (float): Rest-frame wavelength of the line.
        line_name (str): Identifier for the emission line.
        kind (str): Component kind e.g. 'broad', 'narrow', 'outflow', 'fe', 'cont'.
        component (int): Component index for multi-component fits.
        amplitude (float): Initial amplitude guess.
        profile (str): Profile type e.g. 'gaussian', 'lorentzian'.
        how (str): For Fe lines, indicates 'sum' or 'template' mode.
        which (str): Template choice for Fe ('OP' or 'UV').
    """
    center: float
    line_name: str
    kind: str
    component: int = 1
    amplitude: float = 1.0
    profile: str = 'gaussian'
    how: str = ''  # 'sum' or 'template'
    which: str = ''  # 'OP' or 'UV' for template mode

class RegionFitting:
    """
    Fits a spectral region containing multiple emission lines.

    This class:
      - Loads line definitions from YAML or provided dict/list.
      - Normalizes and masks spectra.
      - Builds parameter arrays with bounds.
      - Runs JAX-based minimization (MasterMinimizer).
      - Supports renormalization and parameter mapping.
    """

    def __init__(
        self,
        region_template: Union[str, dict, List[dict]],
        yaml_dir: Optional[Union[str, Path]] = None,
        tied_params: Optional[List[List[Any]]] = None,
        log_mode: bool = False,
        limits_overrides: Optional[Dict[str, FittingLimits]] = None
    ) -> None:
        """
        Initialize RegionFitting.

        Args:
            region_template: Path or name of YAML file, or dict/list defining lines.
            yaml_dir: Directory to search for YAML templates.
            tied_params: Initial parameter tie definitions.
            log_mode: If True, log additional debug info.
            limits_overrides: User-specified FittingLimits per kind.
        """
        # Load and parse region definitions
        self.region_defs = self._load_region(region_template, yaml_dir)
        self.tied_params_sequence = tied_params or []
        self.log_mode = log_mode

        # Prepare mapping of limits: default plus any overrides
        self.limits_map: Dict[str, FittingLimits] = {}
        for kind, cfg in DEFAULT_LIMITS.items():
            default_lim = FittingLimits.from_dict(cfg)
            # Use override if provided, else default
            self.limits_map[kind] = (
                limits_overrides[kind] if limits_overrides and kind in limits_overrides
                else default_lim
            )

        # Attributes to be populated during fitting
        self.inner_limits: Optional[Tuple[float, float]] = None
        self.outer_limits: Optional[Tuple[float, float]] = None
        self.params_dict: Dict[str, int] = {}
        self.initial_params: jnp.ndarray = jnp.array([])
        self.profile_functions: List[Any] = []
        self.list_dependencies: List[str] = []
        self.constraints: Optional[jnp.ndarray] = None
        self.params: Optional[jnp.ndarray] = None
        self.loss: Optional[float] = None

    def _load_region(
        self,
        template: Union[str, dict, List[dict]],
        yaml_dir: Optional[Union[str, Path]]
    ) -> List[LineConfig]:
        """
        Load line definitions from YAML, dict, or list.

        Returns:
            List of LineConfig objects.
        """
        if isinstance(template, str):
            path = Path(template)
            # If name only and yaml_dir given, construct path
            if not path.exists() and yaml_dir:
                path = Path(yaml_dir) / f"{template}.yaml"
            if not path.exists():
                logger.error("Region template not found: %s", template)
                raise FileNotFoundError(f"Region template not found: {template}")
            data = yaml.safe_load(path.read_text())
        elif isinstance(template, dict):
            data = template
        else:
            # Direct list of region entries
            data = {'region': template}

        raw = data.get('region')
        if not isinstance(raw, list):
            logger.error("Region definition missing 'region' list")
            raise ValueError("Region definition must contain a 'region' list")

        # Convert each entry to a LineConfig
        return [LineConfig(**entry) for entry in raw]

    def __call__(
        self,
        spectra: Union[List[Any], jnp.ndarray],
        inner_limits: Optional[Tuple[float, float]] = None,
        outer_limits: Optional[Tuple[float, float]] = None,
        force_cut: bool = False,
        weighted: bool = True,
        renormalize: bool = True,
        exp_factor: Union[float, jnp.ndarray] = 0.0,
        num_steps: int = 1000,
        **kwargs
    ) -> None:
        """
        Run full fitting sequence:
          1) _prep_data
          2) _build_fit_components
          3) _fit
          4) _postprocess
        """
        spec, mask, max_flux, norm_spec = self._prep_data(
            spectra, inner_limits, outer_limits, force_cut
        )
        self._build_fit_components()
        params, loss = self._fit(norm_spec, max_flux, weighted, num_steps)
        self._postprocess(params, loss, max_flux, exp_factor, renormalize)

    def _prep_data(
        self,
        spectra: Union[List[Any], jnp.ndarray],
        inner_limits: Optional[Tuple[float, float]],
        outer_limits: Optional[Tuple[float, float]],
        force_cut: bool
    ) -> Tuple[jnp.ndarray, jnp.ndarray, jnp.ndarray, jnp.ndarray]:
        """
        Preprocess spectra:
          - Apply masks
          - Optionally cut region
          - Normalize flux by max per pixel

        Returns:
            spec, mask, max_flux, normalized spec
        """
        # Set or verify limits
        self.inner_limits = inner_limits or self.inner_limits
        self.outer_limits = outer_limits or self.outer_limits
        if not (self.inner_limits and self.outer_limits):
            raise ValueError("inner_limits and outer_limits must be specified")

        # Build spectrum and mask
        try:
            if isinstance(spectra, list):
                spec, mask = prepare_spectra(spectra)
            else:
                spec, _, _, mask = mask_builder(spectra, outer_limits=self.outer_limits)
                if force_cut:
                    spec, mask = prepare_spectra(spec)
        except Exception as e:
            logger.exception("Failed to preprocess spectra")
            raise ValueError(f"Preprocessing error: {e}")

        # Normalize flux dimension
        try:
            max_flux = jnp.nanmax(jnp.where(mask, 0, spec[..., 1]), axis=-1)
            norm_spec = spec.at[..., 1].divide(max_flux)
        except Exception as e:
            logger.exception("Normalization error")
            raise ValueError(f"Normalization error: {e}")

        return spec, mask, max_flux, norm_spec

    def _build_fit_components(self) -> None:
        """
        Assemble initial parameters, bounds, and profile functions for each line.
        """
        init_list: List[float] = []
        low_list: List[float] = []
        high_list: List[float] = []
        self.profile_functions.clear()
        self.params_dict.clear()
        self.list_dependencies.clear()

        idx = 0
        # Loop over each line configuration
        for cfg in self.region_defs:
            kind = cfg.kind.lower()
            if kind not in self.limits_map:
                logger.error("No limits for kind '%s'", kind)
                raise ValueError(f"No limits defined for kind '{kind}'")
            limits = self.limits_map[kind]
            # Compute constraints and parameter names
            init, high, low, profile, names = self._make_constraints(cfg, limits)
            init_list.extend(init)
            high_list.extend(high)
            low_list.extend(low)
            # Select the correct profile function
            fn = {
                'gaussian': gaussian_func,
                'lorentzian': lorentzian_func,
                'power_law': power_law,
                'fitFeOP': fitFeOP,
                'fitFeUV': fitFeUV,
                'linear': linear
            }.get(profile, gaussian_func)
            self.profile_functions.append(fn)
            # Map each parameter name to an index
            for i, name in enumerate(names):
                key = f"{name}_{cfg.line_name}_{cfg.component}_{cfg.kind}"
                self.params_dict[key] = idx + i
            idx += len(names)

        # Always add a linear continuum fallback
        self.profile_functions.append(linear)
        init_list += [0.0, 0.0]
        high_list += [jnp.inf, jnp.inf]
        low_list += [-jnp.inf, -jnp.inf]

        self.initial_params = jnp.array(init_list)
        self.constraints = self._stack_constraints(low_list, high_list)

    @staticmethod
    def _stack_constraints(low: List[float], high: List[float]) -> jnp.ndarray:
        """
        Utility to stack lower and upper bounds into a (N,2) array.
        """
        return jnp.stack([jnp.array(low), jnp.array(high)], axis=1)

    def _fit(
        self,
        norm_spec: jnp.ndarray,
        max_flux: jnp.ndarray,
        weighted: bool,
        num_steps: int
    ) -> Tuple[jnp.ndarray, float]:
        """
        Perform the JAX-based minimization using MasterMinimizer.
        Returns optimized parameters and final loss.
        """
        model = jit(combine_auto(self.profile_functions))
        minimizer = MasterMinimizer(
            model,
            non_optimize_in_axis=3,
            num_steps=num_steps,
            list_dependencies=self.list_dependencies,
            weighted=weighted
        )
        try:
            params, loss = minimizer(
                self.initial_params,
                *norm_spec.transpose(1, 0, 2),
                self.constraints
            )
        except Exception as e:
            logger.exception("Fitting failed")
            raise RuntimeError(f"Fitting error: {e}")
        return params, loss

    def _postprocess(
        self,
        params: jnp.ndarray,
        loss: float,
        max_flux: jnp.ndarray,
        exp_factor: Union[float, jnp.ndarray],
        renormalize: bool
    ) -> None:
        """
        Scale parameters back to original flux units if requested.
        Store final params and loss.
        """
        self.loss = loss
        if renormalize:
            try:
                scaled = max_flux / (10**exp_factor)
                idxs = self.mapping_params(['amplitude', 'cont', 'scale'])
                params = params.at[:, idxs].multiply(scaled[:, None])
            except Exception as e:
                logger.exception("Renormalization failed")
                raise ValueError(f"Renormalization error: {e}")
        self.params = params

    def _make_constraints(
        self,
        cfg: LineConfig,
        limits: FittingLimits
    ) -> Tuple[List[float], List[float], List[float], str, List[str]]:
        """
        Compute init, upper, lower bounds for a line, along
        with chosen profile and parameter names.
        """
        c = cfg.center
        # Convert velocity limits to wavelength shifts
        cu = c + kms_to_wl(limits.center_shift, c)
        cl = c - kms_to_wl(limits.center_shift, c)
        wu = kms_to_wl(limits.upper_width, c)
        wl = kms_to_wl(limits.lower_width, c)
        # Handle Fe template separately
        if cfg.kind.lower() == 'fe' and cfg.how == 'template':
            names = ['log_FWHM', 'shift', 'scale']
            init = [jnp.log10(1100.), 0.0, 1.0]
            high = [3.5, 100., 100.]
            low = [3.0, -100., 0.0]
            profile = 'fitFe' + cfg.which
        # Power-law continuum
        elif cfg.profile == 'power_law':
            names = ['index', 'b']
            init = [-1.0, 0.0]
            high = [0.0, jnp.inf]
            low = [-jnp.inf, -jnp.inf]
            profile = 'power_law'
        # Default Gaussian/Lorentzian line
        else:
            names = ['amplitude', 'center', 'width']
            init = [cfg.amplitude, c, wl]
            high = [10.0, cu, wu]
            low = [0.0, cl, wl]
            profile = cfg.profile
        return init, high, low, profile, names

    def mapping_params(self, params: Union[str, List[str]]) -> jnp.ndarray:
        """
        Return indices of parameters whose key contains all substrings in params.
        """
        if isinstance(params, str):
            params = [params]
        matches: List[int] = []
        for key, idx in self.params_dict.items():
            if all(p in key for p in params):
                matches.append(idx)
        return jnp.unique(jnp.array(matches))

    @property
    def pandas_params(self) -> pd.DataFrame:
        """Return fit parameters as a pandas DataFrame."""
        return pd.DataFrame(self.params, columns=list(self.params_dict.keys()))

    @property
    def pandas_region(self) -> pd.DataFrame:
        """Return region definitions as a pandas DataFrame."""
        return pd.DataFrame([vars(cfg) for cfg in self.region_defs])
###############################
import pytest
import jax.numpy as jnp
from dataclasses import asdict
from pathlib import Path

test_module_path = Path(__file__).parent / 'region_fitting.py'

# Import the RegionFitting module from the same directory
import importlib.util
spec = importlib.util.spec_from_file_location('region_fitting', test_module_path)
region_mod = importlib.util.module_from_spec(spec)
spec.loader.exec_module(region_mod)

RegionFitting = region_mod.RegionFitting
LineConfig = region_mod.LineConfig
FittingLimits = region_mod.FittingLimits

@pytest.fixture
def simple_region_list():
    # Two lines: a narrow gaussian and an Fe sum component
    return [
        {'center': 5000.0, 'line_name': 'TestLine', 'kind': 'narrow', 'amplitude': 1.0, 'profile': 'gaussian'},
        {'center': 3000.0, 'line_name': 'FeTest', 'kind': 'fe', 'amplitude': 0.5, 'profile': 'gaussian', 'how': 'sum'}
    ]

def test_load_region_from_list(simple_region_list):
    rf = RegionFitting(region_template=simple_region_list)
    assert len(rf.region_defs) == 2
    # Check first config matches input
    cfg = rf.region_defs[0]
    assert cfg.center == 5000.0
    assert cfg.line_name == 'TestLine'
    assert cfg.kind == 'narrow'

def test_limits_overrides(simple_region_list):
    # Override narrow limits
    custom_limits = FittingLimits(upper_width=123.0, lower_width=10.0, center_shift=500.0)
    rf = RegionFitting(region_template=simple_region_list, limits_overrides={'narrow': custom_limits})
    # Ensure override applied
    assert rf.limits_map['narrow'].upper_width == 123.0
    # Default broad unchanged
    assert rf.limits_map['broad'].upper_width == 5000.0

def test_make_constraints_narrow():
    cfg = LineConfig(center=6000.0, line_name='L', kind='narrow')
    limits = FittingLimits(upper_width=200.0, lower_width=50.0, center_shift=2500.0)
    rf = RegionFitting(region_template=[asdict(cfg)])
    init, high, low, profile, names = rf._make_constraints(cfg, limits)
    # Names should be amplitude, center, width
    assert names == ['amplitude', 'center', 'width']
    assert len(init) == 3 and len(high) == 3 and len(low) == 3
    # Width bound equals kms_to_wl(lower_width, center)
    width_lower = low[2]
    expected = region_mod.kms_to_wl(limits.lower_width, cfg.center)
    assert pytest.approx(width_lower, rel=1e-6) == expected

def test_mapping_params_and_stack_constraints():
    rf = RegionFitting(region_template=simple_region_list)
    # Manually set params_dict for mapping test
    rf.params_dict = {'amp_L_1_narrow': 0, 'cent_L_1_narrow': 1, 'width_L_1_narrow': 2}
    idxs = rf.mapping_params(['amplitude', 'narrow'])
    assert jnp.array_equal(idxs, jnp.array([0]))
    # Test stack constraints
    low = [1.0, 2.0]
    high = [3.0, 4.0]
    cons = rf._stack_constraints(low, high)
    assert cons.shape == (2, 2)
    assert cons[0, 0] == 1.0 and cons[0, 1] == 3.0

def test_build_fit_components_and_params():
    # Use simple region list
    rf = RegionFitting(region_template=simple_region_list)
    # Assign dummy inner/outer limits to avoid errors
    rf.inner_limits = (0.0, 1.0)
    rf.outer_limits = (0.0, 1.0)
    # Build components
    rf._build_fit_components()
    # initial_params length = sum params per line + 2 for continuum
    # First line (narrow Gaussian): 3 params, second Fe sum: 3 params, continuum: 2 -> total 8
    assert rf.initial_params.shape[0] == 8
    assert rf.constraints.shape == (8, 2)
    # params_dict keys count also 8
    assert len(rf.params_dict) == 8

def test_unknown_kind_raises():
    bad_cfg = {'center': 123.4, 'line_name': 'X', 'kind': 'unknown'}
    rf = RegionFitting(region_template=[bad_cfg])
    rf.inner_limits = (0,1); rf.outer_limits = (0,1)
    with pytest.raises(ValueError):
        rf._build_fit_components()